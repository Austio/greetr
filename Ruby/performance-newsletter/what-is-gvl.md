Confusing and often maligned - what is the GVL and what does it mean for you as a Ruby developer?

One thing that I find confuses many Rubyists is the Global Virtual Machine Lock, or the GVL. It's a unique feature to CRuby, and doesn't exist in JRuby or TruffleRuby.

Why is it called the GVL?

One thing that's confusing right off the bat is the name - isn't it the GIL? Well, GIL stands for Global Interpreter Lock, and it's something that was removed from Ruby in Ruby 1.9, when Koichi Sasada introduced YARV (Yet Another Ruby VM) to Ruby. We'll talk more about that change later and why it swapped a GIL for a GVL, but for now, let's just set out that the correct terminology for over a decade now has been GVL, not GIL.

So, you may be vaguely aware that this thing called the GVL exists and that it has something to do with parallelism and threads. But what is it *actually*, and how does it affect how Ruby's threads work? Let's dive in.

The TL:DR; is that only one thread in any Ruby process can hold the global VM lock at any given time. Since a thread needs access to the Ruby Virtual Machine to actually run any Ruby code, effectively only one thread can run Ruby code at any given time. However, your programs actually do a large number of things that don't need access to the Ruby Virtual Machine. The most important is waiting on I/O, such as database and network calls. These actions are executed in C, and the GVL is explicitly released by the thread waiting on that I/O to return. When the I/O returns, the thread attempts to reacquire the GVL and continue to do whatever the program says.

Let's break down each piece of this in turn.

Processes vs Threads

What's a process, and what's a thread?

Processes are instances of a computer program. That program is actually run by one or many threads (processes have one or many threads). The process itself isn't really the thing that runs the code - it's more of a collection of shared resources that all of the threads use together.

The most important resources that a process owns are the code (which the threads will then take and execute), the memory, and the file descriptors (sockets, ports, actual files, etc.).

Threads use these shared resources to execute the code. These threads share their memory with each other, and run the code when they are scheduled to by the operating system's kernel. The Ruby runtime itself doesn't manage when threads are executed - the operating system decides that.

There is one additional shared resource in a Ruby process that is extremely important - that's the Global VM Lock. Despite the very authoritative name, there really isn't anything "global" about the GVL. Each Ruby process has it's own GVL, so it might be more accurate to say that it's a "process-wide VM lock". It's "global" in the same sense that a "global variable" is global.

Think of the GVL like the conch shell in the Lord of the Flies - if you have it, you get to speak (or execute Ruby code in this case). If the GVL is already locked by a different thread, other threads must wait for the GVL to be released before they can hold the GVL.

Let's talk a little bit about the thing we're locking - the Ruby Virtual Machine.

What are we locking? The Virtual Machine

A virtual machine is a little bit like a CPU-within-a-CPU. Virtual machines are computer programs that take usually very simple instructions, and those instructions manipulate some internal state. A Turing machine, if it was implemented in software, would be a kind of virtual machine. We call them virtual machines and not machines because they're implemented in software, rather than in hardware, like a CPU is.

So we have a Ruby Virtual Machine that takes a simple instruction set. Those instructions are generated by the Ruby code you write by the interpreter, and then the virtual machine instructions are fed into the Ruby VM by a thread.

Before Ruby 1.9, Ruby didn't really have a separate virtual machine step - it just had an interpreter. As your Ruby program ran, it actually interpreted each line of Ruby as it went. Now, we just interpret the code once, turn into a series of VM instructions, and then execute those instructions. This is much faster than interpreting Ruby.

You can see what Ruby's VM instruction sequences look like by using the --dump option on the command line.

You can execute Ruby from the command line using the -e option:

$ ruby -e "puts 1 + 1"
2

You can then dump the instructions for this simple program by calling --dump=insns:

$ ruby --dump=insns -e "puts 1 + 1"
== disasm: #<ISeq:<main>@-e:1 (1,0)-(1,10)> (catch: FALSE)
0000 putself                                                          (   1)[Li]
0001 putobject_INT2FIX_1_
0002 putobject_INT2FIX_1_
0003 opt_plus                     <callinfo!mid:+, argc:1, ARGS_SIMPLE>, <callcache>
0006 opt_send_without_block       <callinfo!mid:puts, argc:1, FCALL|ARGS_SIMPLE>, <callcache>
0009 leave

Ruby is a "stack-based" VM. You can see how this works by looking at the generated instructions here - we add the integer 1 to the stack two times, than call plus. When plus is called, there are two integers on the stack. Those two integers are replaced by the result, 2, which is then on the stack.

I mentioned before that your threads don't need the GVL all the time. You can see this by searching Ruby's source code - in particular, note how often the GVL is mentioned in io.c. You can also see this in gems that have C-extensions, such as pg, the Ruby postgres gem. When doing IO, the C code that's being run must explicitly lock and unlock the GVL.

So, that's how the GVL works. What does it all mean, though?

The upshot - what it all means for you

I sometimes see inaccurate descriptions of Ruby's multithreading or parallel behavior because the author is playing "fast and loose" with terminology. Given all that you now know about the GVL, I'd like to be very precise.

Performing two operations concurrently means that the start and end times of those operations overlapped at some point. For example, you and I sit down to a sign a contract. However, there is only one pen. I sign where I'm supposed to, hand the pen to you, and then you sign. Then, you hand the pen back to me and I initial a few lines. You might say that we signed the contract concurrently, but never in parallel - there was only one pen, so we couldn't sign the contract at the exact same time.

Peforming operations in parallel means that we are doing those operations *at the exact same instant*. In my contract example, it would mean that there were two pens (and probably two copies of the contract, otherwise it would get a little crowded).

In CRuby, we can execute Ruby code concurrently but not in parallel. Only one thread can hold the GVL at any time, so parallel execution of Ruby code is impossible.

However, we can still do important things in parallel, such as waiting on I/O. It would be inaccurate to say that "Ruby is not parallel", because the runtime's threads *do* run in parallel when waiting on I/O. They're not running Ruby language code, but they're Ruby threads all the same.

This also means in an important sense that Ruby is "multi-core". Whenever a thread does not need to hold the GVL, it can and probably will be scheduled onto many different cores by the kernel thread scheduler.

This also means that "how many threads does my Sidekiq or Puma process need" is a question answered by "how much time does that thread spend in non-GVL execution?" or "how much time does my program spend waiting on I/O?" Workloads ery high percentages of time spent in I/O (75%+ or more) often benefit from 16 threads or even more, but more typical workloads see benefit from just 3 to 5 threads.

Adding more threads to a Ruby process helps us to improve CPU utilization at less memory cost than an entire additional process. Adding 1 process might use 512MB of memory, but adding 1 thread will probably cause less than 64MB of additional memory usage. With 2 threads instead of 1, when the first thread releases the GVL and listens on I/O, our 2nd thread can either pick up new work to do, increasing throughput and utilization of our server.

For now, the GVL exists and is going nowhere. It's simply too complicated to remove it. Other languages have similar locks: CPython has one too. The vaunted V8 JavaScript engine essentially has a "GVL" too, except V8 can create multiple VMs (V8 calls them Isolates, but only one thread can access an Isolate at a time).

I hope this has been a complete introduction to the GVL for you - if you have any questions, you can reply directly to this email.

1. How difficult was it to write?
2. How hard is it to understand? (happens when clearly reflecting problems domain)
3. How expensive will it be to change?

1. How many verse variants are there
2. Which ways are most alike, in what way
3. Which verses are most different, what way
4. What rule determines which verses should be sung next

Dry Should save you money
- Names are important in DRY, name what they represent not what they do
 - using generic beverage instead of beer (could change to kool-aid as beverage)

Aim to reduce future cost - distressing to see good intentions fail so spectacularly
- Problem is not bad intention, it’s insufficient patience

### 2 Test Driving Shameless Green
Getting to green quickly in red/green/refactor is often at odds with writing perfectly changable code

Don't fret on first test to write, just do it, ow you will slow yourself down unneededly
  Setup - Create env for test
  Do - Perform test
  Verify - Confirm results
  
When doing TDD you want to do the simplest thing that it can do without increasing complexity
Uncle Bob -> As tests get more specific, code gets more generic

When faced with DRYing question these
1. Does the change i'm contemplating make the code harder to understand?
2. What is the future cost of doing nothing now?
3. When will the future arrive, how soon will i get more information?

Shameless Green = optmizing for understandability, not changability and patientlytolerating duplication to reveal underlying abstraction

Case vs If = Case says these are explicit examples of a similar thing

Duplication = Duplication is useful when it supplies independent, specific examples of a general concept that you don’t yet understand.  Not ok when copies one you already do understand
